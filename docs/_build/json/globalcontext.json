{
  "embedded": false,
  "project": "hello_project",
  "release": "1.0.0",
  "version": "1.0.0",
  "last_updated": null,
  "copyright": "2021, hello_project developers",
  "master_doc": "index",
  "root_doc": "index",
  "use_opensearch": "",
  "docstitle": "hello_project 1.0.0 documentation",
  "shorttitle": "hello_project 1.0.0 documentation",
  "show_copyright": true,
  "show_sphinx": true,
  "has_source": true,
  "show_source": true,
  "sourcelink_suffix": ".txt",
  "file_suffix": ".fjson",
  "link_suffix": ".html",
  "script_files": [
    "_static/documentation_options.js",
    "_static/jquery.js",
    "_static/underscore.js",
    "_static/doctools.js",
    "_static/clipboard.min.js",
    "_static/copybutton.js"
  ],
  "language": null,
  "css_files": [
    "_static/pygments.css",
    "_static/css/theme.css",
    "_static/copybutton.css"
  ],
  "sphinx_version": "4.3.0",
  "sphinx_version_tuple": [4, 3, 0, "final", 0],
  "style": "css/theme.css",
  "rellinks": [["genindex", "General Index", "I", "index"]],
  "builder": "json",
  "parents": [],
  "logo": "",
  "favicon": "",
  "html5_doctype": true,
  "theme_nosidebar": "false",
  "theme_sidebarwidth": "230",
  "theme_body_min_width": "450",
  "theme_body_max_width": "800",
  "theme_navigation_with_keys": "False",
  "theme_globaltoc_collapse": "true",
  "theme_globaltoc_includehidden": "false",
  "theme_globaltoc_maxdepth": "",
  "theme_canonical_url": "",
  "theme_analytics_id": "",
  "theme_analytics_anonymize_ip": "False",
  "theme_collapse_navigation": "True",
  "theme_sticky_navigation": "True",
  "theme_navigation_depth": "4",
  "theme_includehidden": "True",
  "theme_titles_only": "",
  "theme_logo_only": "",
  "theme_display_version": "True",
  "theme_prev_next_buttons_location": "bottom",
  "theme_style_external_links": "False",
  "theme_style_nav_header_background": "",
  "theme_vcs_pageview_mode": "",
  "copybutton_prompt_text": "",
  "copybutton_prompt_is_regexp": false,
  "copybutton_only_copy_prompt_lines": true,
  "copybutton_remove_prompts": true,
  "copybutton_copy_empty_lines": true,
  "copybutton_line_continuation_character": "",
  "copybutton_here_doc_delimiter": "",
  "copybutton_image_path": "copy-button.svg",
  "copybutton_selector": "div.highlight pre",
  "copybutton_format_func": "function escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n// Callback when a copy button is clicked. Will be passed the node that was clicked\n// should then grab the text and replace pieces of text that shouldn't be used in output\nfunction formatCopyText(textContent, copybuttonPromptText, isRegexp = false, onlyCopyPromptLines = true, removePrompts = true, copyEmptyLines = true, lineContinuationChar = \"\", hereDocDelim = \"\") {\n\n    var regexp;\n    var match;\n\n    // Do we check for line continuation characters and \"HERE-documents\"?\n    var useLineCont = !!lineContinuationChar\n    var useHereDoc = !!hereDocDelim\n\n    // create regexp to capture prompt and remaining line\n    if (isRegexp) {\n        regexp = new RegExp('^(' + copybuttonPromptText + ')(.*)')\n    } else {\n        regexp = new RegExp('^(' + escapeRegExp(copybuttonPromptText) + ')(.*)')\n    }\n\n    const outputLines = [];\n    var promptFound = false;\n    var gotLineCont = false;\n    var gotHereDoc = false;\n    const lineGotPrompt = [];\n    for (const line of textContent.split('\\n')) {\n        match = line.match(regexp)\n        if (match || gotLineCont || gotHereDoc) {\n            promptFound = regexp.test(line)\n            lineGotPrompt.push(promptFound)\n            if (removePrompts && promptFound) {\n                outputLines.push(match[2])\n            } else {\n                outputLines.push(line)\n            }\n            gotLineCont = line.endsWith(lineContinuationChar) & useLineCont\n            if (line.includes(hereDocDelim) & useHereDoc)\n                gotHereDoc = !gotHereDoc\n        } else if (!onlyCopyPromptLines) {\n            outputLines.push(line)\n        } else if (copyEmptyLines && line.trim() === '') {\n            outputLines.push(line)\n        }\n    }\n\n    // If no lines with the prompt were found then just use original lines\n    if (lineGotPrompt.some(v => v === true)) {\n        textContent = outputLines.join('\\n');\n    }\n\n    // Remove a trailing newline to avoid auto-running when pasting\n    if (textContent.endsWith(\"\\n\")) {\n        textContent = textContent.slice(0, -1)\n    }\n    return textContent\n}\n"
}
